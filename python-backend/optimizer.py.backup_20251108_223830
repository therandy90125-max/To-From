"""
Qiskit-based Portfolio Optimization
[EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]
PROPER IMPLEMENTATION: Classical Mean-Variance + Quantum QUBO
"""

import numpy as np
import pandas as pd
from qiskit_algorithms import QAOA, NumPyMinimumEigensolver, VQE
from qiskit_algorithms.optimizers import COBYLA
from qiskit.primitives import StatevectorSampler
from qiskit_optimization import QuadraticProgram
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit.circuit.library import TwoLocal
import yfinance as yf
from datetime import datetime, timedelta
from typing import List, Dict, Tuple, Optional
from scipy.optimize import minimize
import warnings
import signal
import threading
from functools import wraps
warnings.filterwarnings('ignore')

# Constants for quantum optimization
QUANTUM_TIMEOUT_SECONDS = 60  # 1 minute timeout ([EMOJI], [EMOJI] [EMOJI])
WEIGHT_THRESHOLD = 1e-6
QUANTUM_NOISE_RANGE = 0.01
PENALTY_MULTIPLIER = 100.0
DEFAULT_QAOA_MAXITER = 50  # [EMOJI] [EMOJI] [EMOJI] ([EMOJI]: 200)


class PortfolioOptimizer:
    """Qiskit[EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI] - PROPER QUANTUM IMPLEMENTATION"""
    
    def __init__(self, tickers: List[str], risk_factor: float = 0.5, initial_weights: List[float] = None, fast_mode: bool = False):
        """
        Args:
            tickers: [EMOJI] [EMOJI] [EMOJI] ([EMOJI]: ['AAPL', 'GOOGL', 'MSFT'])
            risk_factor: [EMOJI] [EMOJI] (0.0 ~ 1.0, [EMOJI] [EMOJI])
            initial_weights: [EMOJI] [EMOJI] [EMOJI] ([EMOJI], None[EMOJI] [EMOJI] [EMOJI])
            fast_mode: [EMOJI] [EMOJI] [EMOJI] (reps=1, maxiter=50, [EMOJI]: False)
        """
        self.tickers = tickers
        self.risk_factor = risk_factor
        self.initial_weights = initial_weights
        self.fast_mode = fast_mode
        self.expected_returns = None
        self.covariance_matrix = None
        self.data = None
        self.returns_data = None  # Daily returns for optimization
        
        # [EMOJI] [EMOJI]
        if initial_weights is not None:
            self._validate_initial_weights()
    
    def _validate_initial_weights(self):
        """initial_weights [EMOJI] [EMOJI]"""
        n = len(self.tickers)
        
        if len(self.initial_weights) != n:
            raise ValueError(
                f"initial_weights [EMOJI]({len(self.initial_weights)}) != tickers [EMOJI]({n})"
            )
        
        # risk_factor [EMOJI] [EMOJI]
        if not (0 <= self.risk_factor <= 1):
            raise ValueError(
                f"risk_factor[EMOJI] 0~1 [EMOJI] [EMOJI]. [EMOJI]: {self.risk_factor}"
            )
        
    def _validate_returns_and_covariance(self):
        """returns[EMOJI] covariance_matrix [EMOJI]"""
        n = len(self.tickers)
        
        if self.expected_returns is not None:
            if len(self.expected_returns) != n:
                raise ValueError(
                    f"expected_returns [EMOJI]({len(self.expected_returns)}) != tickers [EMOJI]({n})"
                )
        
        if self.covariance_matrix is not None:
            if self.covariance_matrix.shape != (n, n):
                raise ValueError(
                    f"covariance_matrix [EMOJI]({self.covariance_matrix.shape})[EMOJI] [EMOJI]. [EMOJI]: ({n}, {n})"
                )
            
            # [EMOJI] [EMOJI] [EMOJI] [EMOJI]
            if not np.allclose(self.covariance_matrix, self.covariance_matrix.T):
                raise ValueError("covariance_matrix[EMOJI] [EMOJI] [EMOJI] [EMOJI]")
        
    def fetch_data(self, period: str = "1y") -> pd.DataFrame:
        """Yahoo Finance[EMOJI] [EMOJI] [EMOJI] [EMOJI]"""
        print(f"[EMOJI] [EMOJI] [EMOJI]: {', '.join(self.tickers)}")
        
        data = {}
        for ticker in self.tickers:
            try:
                stock = yf.Ticker(ticker)
                hist = stock.history(period=period)
                if not hist.empty:
                    data[ticker] = hist['Close']
                    print(f"[OK] {ticker}: {len(hist)}[EMOJI] [EMOJI]")
                else:
                    print(f"[WARN] {ticker}: [EMOJI] [EMOJI]")
            except Exception as e:
                print(f"[ERROR] {ticker} [EMOJI]: {str(e)}")
        
        if not data:
            raise ValueError("[EMOJI] [EMOJI] [EMOJI] [EMOJI].")
        
        self.data = pd.DataFrame(data)
        return self.data
    
    def calculate_returns(self) -> Tuple[np.ndarray, np.ndarray, pd.DataFrame]:
        """[EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]"""
        if self.data is None:
            raise ValueError("[EMOJI] fetch_data()[EMOJI] [EMOJI].")
        
        # [EMOJI] [EMOJI] [EMOJI]
        returns = self.data.pct_change().dropna()
        self.returns_data = returns  # Store for optimization
        
        # [EMOJI] [EMOJI] ([EMOJI])
        self.expected_returns = returns.mean().values * 252
        
        # [EMOJI] [EMOJI] ([EMOJI])
        self.covariance_matrix = returns.cov().values * 252
        
        print(f"[EMOJI] [EMOJI] [EMOJI] [EMOJI]: {len(self.expected_returns)}[EMOJI] [EMOJI]")
        print(f"[EMOJI] [EMOJI] [EMOJI]: {self.covariance_matrix.shape}")
        
        return self.expected_returns, self.covariance_matrix, returns
    
    def classical_portfolio_optimization(self) -> Dict:
        """
        Classical Markowitz Mean-Variance Optimization
        Uses scipy.optimize.minimize with proper mean-variance formulation
        """
        if self.expected_returns is None or self.covariance_matrix is None:
            self.calculate_returns()
        
        n_assets = len(self.tickers)
        mean_returns = self.expected_returns
        cov_matrix = self.covariance_matrix
        
        print(f"\n{'='*60}")
        print(f"[CLASSICAL] MEAN-VARIANCE OPTIMIZATION")
        print(f"{'='*60}")
        print(f"  Number of assets: {n_assets}")
        print(f"  Risk factor: {self.risk_factor}")
        print(f"{'='*60}\n")
        
        # Objective function: Minimize -(returns - risk_penalty)
        def objective(weights):
            portfolio_return = np.dot(weights, mean_returns)
            portfolio_variance = np.dot(weights.T, np.dot(cov_matrix, weights))
            portfolio_std = np.sqrt(portfolio_variance)
            
            # Sharpe-like objective: maximize return - risk_factor * risk
            return -(portfolio_return - self.risk_factor * portfolio_std)
        
        # Constraints: Sum of weights = 1
        constraints = [
            {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}
        ]
        
        # Bounds: 0 <= weight <= 1
        bounds = tuple((0, 1) for _ in range(n_assets))
        
        # Initial guess: equal weights
        initial_weights = np.array([1.0 / n_assets] * n_assets)
        
        # Optimize
        print("[EMOJI] [EMOJI] [EMOJI] [EMOJI] (scipy.optimize.minimize)...")
        result = minimize(
            objective,
            initial_weights,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints,
            options={'maxiter': 1000, 'ftol': 1e-9}
        )
        
        if not result.success:
            print(f"[WARN] Classical optimization warning: {result.message}")
            # Fallback to equal weights if optimization fails
            weights = initial_weights
        else:
            weights = result.x
        
        # Normalize to ensure sum = 1
        weights = weights / np.sum(weights) if np.sum(weights) > 0 else initial_weights
        
        # Calculate metrics
        portfolio_return = np.dot(weights, mean_returns)
        portfolio_variance = np.dot(weights.T, np.dot(cov_matrix, weights))
        portfolio_std = np.sqrt(portfolio_variance)
        sharpe_ratio = portfolio_return / portfolio_std if portfolio_std > 0 else 0.0
        
        # Filter out near-zero weights
        selected_tickers = [self.tickers[i] for i in range(n_assets) if weights[i] > 1e-6]
        selected_weights = [float(weights[i]) for i in range(n_assets) if weights[i] > 1e-6]
        
        print(f"\n{'='*60}")
        print(f"[SUCCESS] CLASSICAL OPTIMIZATION COMPLETED!")
        print(f"{'='*60}")
        print(f"  Selected assets: {selected_tickers}")
        print(f"  Weights: {[f'{w:.2%}' for w in selected_weights]}")
        print(f"  Expected return: {portfolio_return:.2%}")
        print(f"  Risk (std): {portfolio_std:.2%}")
        print(f"  Sharpe ratio: {sharpe_ratio:.4f}")
        print(f"{'='*60}\n")
        
        return {
            'selected_tickers': selected_tickers,
            'weights': selected_weights,
            'expected_return': float(portfolio_return),
            'risk': float(portfolio_std),
            'sharpe_ratio': float(sharpe_ratio),
            'method': 'classical',
            'optimization_success': result.success if hasattr(result, 'success') else True,
            'quantum_verified': False
        }
    
    def quantum_portfolio_optimization_qaoa(self, reps: int = None, precision: int = 4) -> Dict:
        """
        REAL Quantum Portfolio Optimization using Qiskit QAOA with timeout protection
        
        Formulates portfolio optimization as QUBO (Quadratic Unconstrained Binary Optimization)
        with binary encoding of weights (precision bits per asset)
        
        QAOA reps [EMOJI] [EMOJI]:
        - reps=1: ~60[EMOJI], [EMOJI] [EMOJI] 65-75% ([EMOJI]/[EMOJI], [EMOJI])
        - reps=2: ~150[EMOJI], [EMOJI] [EMOJI] 75-80% ([EMOJI] [EMOJI])
        - reps=3: ~300[EMOJI], [EMOJI] [EMOJI] 85% ([EMOJI] [EMOJI] [EMOJI])
        
        [EMOJI] [EMOJI]:
        - QAOA[EMOJI] [EMOJI] layer[EMOJI] 2^n [EMOJI] [EMOJI] [EMOJI]
        - reps=3 → reps=1[EMOJI] [EMOJI] [EMOJI] [EMOJI] 1/3[EMOJI] [EMOJI]
        - Portfolio optimization[EMOJI] 1-layer[EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]
        
        Args:
            reps: Number of QAOA layers (default: 1, [EMOJI]/[EMOJI])
            precision: Number of bits per asset for weight encoding (default: 4)
        
        Returns:
            Quantum-optimized portfolio with quantum-specific metrics
        """
        if self.expected_returns is None or self.covariance_matrix is None:
            self.calculate_returns()
        
        # returns[EMOJI] covariance [EMOJI]
        self._validate_returns_and_covariance()
        
        n_assets = len(self.tickers)
        mean_returns = self.expected_returns
        cov_matrix = self.covariance_matrix
        
        # Fast Mode [EMOJI] ([EMOJI] [EMOJI])
        if reps is None:
            reps = 1 if self.fast_mode else 2  # Fast: 1, Precise: 2
        
        maxiter = DEFAULT_QAOA_MAXITER if self.fast_mode else 100
        
        print(f"\n{'='*60}")
        print(f"[QUANTUM] QAOA PORTFOLIO OPTIMIZATION")
        print(f"{'='*60}")
        print(f"  Number of assets: {n_assets}")
        print(f"  Mode: {'[FAST MODE]' if self.fast_mode else '[PRECISE MODE]'}")
        print(f"  QAOA reps (layers): {reps}")
        print(f"  Max iterations: {maxiter}")
        print(f"  Weight precision (bits per asset): {precision}")
        print(f"  Risk factor: {self.risk_factor}")
        print(f"  Total qubits: {n_assets * precision}")
        print(f"  Timeout: {QUANTUM_TIMEOUT_SECONDS} seconds")
        print(f"{'='*60}\n")
        
        try:
            # Build QUBO formulation using helper method
            lambda_param = 1 - self.risk_factor
            qp, linear_coeffs, quadratic_coeffs = self._build_qubo_formulation(
                n_assets, precision, mean_returns, cov_matrix, lambda_param
            )
            
            print(f"  - QUBO formulation complete")
            print(f"  - Linear terms: {len(linear_coeffs)}")
            print(f"  - Quadratic terms: {len(quadratic_coeffs)}")
            print(f"  - Constraints: {qp.get_num_linear_constraints()}")
            
            # Solve using QAOA with timeout protection
            print(f"  - Initializing QAOA solver...")
            optimizer = COBYLA(maxiter=maxiter)
            sampler = StatevectorSampler()
            qaoa = QAOA(sampler=sampler, optimizer=optimizer, reps=reps)
            quantum_solver = MinimumEigenOptimizer(qaoa)
            
            print(f"  - Running QAOA optimization (timeout: {QUANTUM_TIMEOUT_SECONDS}s)...")
            print(f"  - Quantum noise applied to encourage different solution space")
            
            # Execute with timeout using threading
            result_container = {'result': None, 'exception': None}
            
            def solve_with_timeout():
                try:
                    result_container['result'] = quantum_solver.solve(qp)
                except Exception as e:
                    result_container['exception'] = e
            
            thread = threading.Thread(target=solve_with_timeout)
            thread.daemon = True
            thread.start()
            thread.join(timeout=QUANTUM_TIMEOUT_SECONDS)
            
            if thread.is_alive():
                print(f"[ERROR] Quantum optimization timed out after {QUANTUM_TIMEOUT_SECONDS} seconds")
                raise TimeoutError(f"Quantum optimization exceeded {QUANTUM_TIMEOUT_SECONDS} second timeout")
            
            if result_container['exception']:
                raise result_container['exception']
            
            if result_container['result'] is None:
                raise RuntimeError("Quantum optimization returned no result")
            
            result = result_container['result']
            print(f"  - QAOA optimization completed!")
            print(f"  - Optimal value (energy): {result.fval:.6f}")
            
            # Decode solution using helper method
            weights = self._decode_quantum_solution(result, n_assets, precision)
            
            # [EMOJI] [EMOJI]
            if weights is None or len(weights) != n_assets:
                raise RuntimeError("QAOA [EMOJI] [EMOJI]: [EMOJI] [EMOJI] [EMOJI]")
            
            # [EMOJI] [EMOJI] [EMOJI]
            weight_sum = np.sum(weights)
            if not (0.99 <= weight_sum <= 1.01):
                print(f"[WARNING] [EMOJI] [EMOJI] = {weight_sum:.4f} ([EMOJI]: 1.0), [EMOJI] [EMOJI]...")
                if weight_sum > 0:
                    weights = weights / weight_sum
                else:
                    weights = np.ones(n_assets) / n_assets
            
            # [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]
            if np.any(weights < -1e-6):
                negative_weights = weights[weights < -1e-6]
                print(f"[WARNING] [EMOJI] [EMOJI] [EMOJI]: {negative_weights}")
                weights = np.maximum(weights, 0)  # [EMOJI] 0[EMOJI]
                if np.sum(weights) > 0:
                    weights = weights / np.sum(weights)  # [EMOJI]
            
            # Calculate metrics using helper method
            metrics = self._calculate_quantum_metrics(weights, mean_returns, cov_matrix, result)
            
            # Filter out near-zero weights
            selected_tickers = [self.tickers[i] for i in range(n_assets) if weights[i] > WEIGHT_THRESHOLD]
            selected_weights = [float(weights[i]) for i in range(n_assets) if weights[i] > WEIGHT_THRESHOLD]
            
            print(f"\n{'='*60}")
            print(f"[SUCCESS] QUANTUM OPTIMIZATION COMPLETED!")
            print(f"{'='*60}")
            print(f"  Selected assets: {selected_tickers}")
            print(f"  Weights: {[f'{w:.2%}' for w in selected_weights]}")
            print(f"  Expected return: {metrics['portfolio_return']:.2%}")
            print(f"  Risk (std): {metrics['portfolio_std']:.2%}")
            print(f"  Sharpe ratio: {metrics['sharpe_ratio']:.4f}")
            print(f"  Quantum energy: {metrics['quantum_energy']:.6f}")
            print(f"  Quantum probability: {metrics['quantum_probability']:.4f}")
            print(f"  QAOA reps: {reps}")
            print(f"{'='*60}\n")
            
            return {
                'selected_tickers': selected_tickers,
                'weights': selected_weights,
                'expected_return': float(metrics['portfolio_return']),
                'risk': float(metrics['portfolio_std']),
                'sharpe_ratio': float(metrics['sharpe_ratio']),
                'method': 'quantum',
                'reps': reps,
                'quantum_energy': metrics['quantum_energy'],
                'quantum_probability': metrics['quantum_probability'],
                'quantum_verified': True,
                'optimization_value': metrics['quantum_energy']
            }
            
        except TimeoutError as e:
            print(f"[ERROR] {str(e)}")
            print("[FALLBACK] Falling back to classical optimization...")
            return self.classical_portfolio_optimization()
        except Exception as e:
            print(f"[ERROR] Quantum optimization failed: {str(e)}")
            import traceback
            traceback.print_exc()
            # Fallback to classical if quantum fails
            print("[FALLBACK] Falling back to classical optimization...")
            return self.classical_portfolio_optimization()
    
    def optimize_classical(self) -> Dict:
        """Wrapper for classical optimization"""
        return self.classical_portfolio_optimization()
    
    def optimize_quantum(self, reps: int = 1, precision: int = 4) -> Dict:
        """Wrapper for quantum optimization with timeout"""
        return self.quantum_portfolio_optimization_qaoa(reps=reps, precision=precision)
    
    def _build_qubo_formulation(self, n_assets: int, precision: int, mean_returns: np.ndarray, 
                                cov_matrix: np.ndarray, lambda_param: float) -> Tuple[QuadraticProgram, Dict, Dict]:
        """
        Build QUBO formulation for quantum optimization
        
        Returns:
            Tuple of (QuadraticProgram, linear_coeffs, quadratic_coeffs)
        """
        qp = QuadraticProgram()
        
        # Add binary variables
        for i in range(n_assets):
            for bit in range(precision):
                qp.binary_var(f'x_{i}_{bit}')
        
        # Linear terms (expected return)
        np.random.seed(42)  # For reproducibility
        quantum_noise = np.random.uniform(-QUANTUM_NOISE_RANGE, QUANTUM_NOISE_RANGE, n_assets)
        
        linear_coeffs = {}
        for i in range(n_assets):
            for bit in range(precision):
                weight_value = (2 ** bit) / (2 ** precision - 1)
                var_name = f'x_{i}_{bit}'
                adjusted_return = mean_returns[i] + quantum_noise[i]
                linear_coeffs[var_name] = -lambda_param * adjusted_return * weight_value
        
        # Quadratic terms (covariance/risk)
        quadratic_coeffs = {}
        for i in range(n_assets):
            for j in range(n_assets):
                for bit_i in range(precision):
                    for bit_j in range(precision):
                        weight_i = (2 ** bit_i) / (2 ** precision - 1)
                        weight_j = (2 ** bit_j) / (2 ** precision - 1)
                        key = (f'x_{i}_{bit_i}', f'x_{j}_{bit_j}')
                        quadratic_coeffs[key] = (1 - lambda_param) * cov_matrix[i, j] * weight_i * weight_j
        
        # Add penalty terms for constraint: sum(weights) = 1
        penalty_weight = PENALTY_MULTIPLIER * n_assets
        
        for i in range(n_assets):
            for bit_i in range(precision):
                weight_i = (2 ** bit_i) / (2 ** precision - 1)
                var_i = f'x_{i}_{bit_i}'
                
                # Self-penalty
                if (var_i, var_i) not in quadratic_coeffs:
                    quadratic_coeffs[(var_i, var_i)] = penalty_weight * weight_i * weight_i
                else:
                    quadratic_coeffs[(var_i, var_i)] += penalty_weight * weight_i * weight_i
                
                # Cross-penalty
                for j in range(n_assets):
                    if i != j:
                        for bit_j in range(precision):
                            weight_j = (2 ** bit_j) / (2 ** precision - 1)
                            var_j = f'x_{j}_{bit_j}'
                            key = (var_i, var_j) if var_i < var_j else (var_j, var_i)
                            if key not in quadratic_coeffs:
                                quadratic_coeffs[key] = 2 * penalty_weight * weight_i * weight_j
                            else:
                                quadratic_coeffs[key] += 2 * penalty_weight * weight_i * weight_j
                
                # Linear penalty
                if var_i not in linear_coeffs:
                    linear_coeffs[var_i] = -2 * penalty_weight * weight_i
                else:
                    linear_coeffs[var_i] += -2 * penalty_weight * weight_i
        
        qp.minimize(linear=linear_coeffs, quadratic=quadratic_coeffs)
        
        return qp, linear_coeffs, quadratic_coeffs
    
    def _decode_quantum_solution(self, result, n_assets: int, precision: int) -> np.ndarray:
        """Decode binary quantum solution to continuous weights"""
        weights = np.zeros(n_assets)
        for i in range(n_assets):
            for bit in range(precision):
                var_name = f'x_{i}_{bit}'
                if var_name in result.variables_dict and result.variables_dict[var_name] > 0.5:
                    weights[i] += (2 ** bit) / (2 ** precision - 1)
        
        # Normalize
        if np.sum(weights) > 0:
            weights = weights / np.sum(weights)
        else:
            weights = np.ones(n_assets) / n_assets
        
        return weights
    
    def _calculate_quantum_metrics(self, weights: np.ndarray, mean_returns: np.ndarray, 
                                   cov_matrix: np.ndarray, result) -> Dict:
        """Calculate portfolio metrics from quantum solution"""
        portfolio_return = np.dot(weights, mean_returns)
        portfolio_variance = np.dot(weights.T, np.dot(cov_matrix, weights))
        portfolio_std = np.sqrt(portfolio_variance)
        sharpe_ratio = portfolio_return / portfolio_std if portfolio_std > 0 else 0.0
        
        quantum_energy = float(result.fval)
        quantum_probability = getattr(result, 'probability', None)
        if quantum_probability is None:
            quantum_probability = 1.0 / (1.0 + abs(quantum_energy))
        
        return {
            'portfolio_return': portfolio_return,
            'portfolio_std': portfolio_std,
            'sharpe_ratio': sharpe_ratio,
            'quantum_energy': quantum_energy,
            'quantum_probability': float(quantum_probability)
        }
    
    def calculate_portfolio_metrics(self, weights: List[float]) -> Dict:
        """[EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]"""
        if self.expected_returns is None or self.covariance_matrix is None:
            self.calculate_returns()
        
        if len(weights) != len(self.tickers):
            raise ValueError(f"[EMOJI] [EMOJI]({len(weights)})[EMOJI] [EMOJI] [EMOJI]({len(self.tickers)})[EMOJI] [EMOJI] [EMOJI].")
        
        weights_array = np.array(weights)
        
        # [EMOJI] [EMOJI] [EMOJI]
        portfolio_return = np.dot(weights_array, self.expected_returns)
        
        # [EMOJI] [EMOJI]
        portfolio_risk = np.sqrt(np.dot(weights_array, np.dot(self.covariance_matrix, weights_array)))
        
        # [EMOJI] [EMOJI] [EMOJI]
        sharpe_ratio = portfolio_return / portfolio_risk if portfolio_risk > 0 else 0.0
        
        return {
            'expected_return': float(portfolio_return),
            'risk': float(portfolio_risk),
            'sharpe_ratio': float(sharpe_ratio)
        }
    
    def optimize_with_weights(self, method: str = 'quantum', **kwargs) -> Dict:
        """
        [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]
        
        Returns:
            [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]
        """
        if self.initial_weights is None:
            raise ValueError("[EMOJI] [EMOJI] [EMOJI] [EMOJI].")
        
        # initial_weights[EMOJI] [EMOJI] tickers[EMOJI] [EMOJI] [EMOJI] [EMOJI]
        if len(self.initial_weights) != len(self.tickers):
            raise ValueError(f"initial_weights[EMOJI] [EMOJI]({len(self.initial_weights)})[EMOJI] tickers[EMOJI] [EMOJI]({len(self.tickers)})[EMOJI] [EMOJI] [EMOJI].")
        
        if abs(sum(self.initial_weights) - 1.0) > 0.01:
            raise ValueError(f"[EMOJI] [EMOJI] 1.0[EMOJI] [EMOJI]. [EMOJI]: {sum(self.initial_weights)}")
        
        if self.expected_returns is None or self.covariance_matrix is None:
            self.calculate_returns()
        
        # [EMOJI] [EMOJI] [EMOJI] [EMOJI]
        original_metrics = self.calculate_portfolio_metrics(self.initial_weights)
        
        # [EMOJI] [EMOJI]
        reps = kwargs.get('reps', 1)  # [EMOJI]: 1 ([EMOJI]/[EMOJI]), [EMOJI]: 2 [EMOJI]
        precision = kwargs.get('precision', 4)
        
        if method == 'quantum':
            optimized_result = self.quantum_portfolio_optimization_qaoa(reps=reps, precision=precision)
        else:
            optimized_result = self.classical_portfolio_optimization()
        
        # [EMOJI] [EMOJI] [EMOJI] [EMOJI] (optimized_result[EMOJI] selected[EMOJI] [EMOJI])
        n = len(self.tickers)
        optimized_weights = [0.0] * n
        
        # Map selected weights back to full vector
        selected_tickers = optimized_result['selected_tickers']
        selected_weights = optimized_result['weights']
        
        for ticker, weight in zip(selected_tickers, selected_weights):
            idx = self.tickers.index(ticker)
            optimized_weights[idx] = weight
        
        # [EMOJI]
        weight_sum = sum(optimized_weights)
        if weight_sum > 0:
            optimized_weights = [w / weight_sum for w in optimized_weights]
        else:
            optimized_weights = self.initial_weights.copy()
        
        # [EMOJI] [EMOJI] [EMOJI] [EMOJI]
        optimized_metrics = self.calculate_portfolio_metrics(optimized_weights)
        
        # [EMOJI] [EMOJI] ([EMOJI] [EMOJI]: [EMOJI] [EMOJI] [EMOJI] 0[EMOJI] [EMOJI])
        EPSILON = 1e-6  # [EMOJI] [EMOJI] [EMOJI] [EMOJI]
        
        # [EMOJI] [EMOJI] (%)
        if abs(original_metrics['expected_return']) > EPSILON:
            return_improvement = ((optimized_metrics['expected_return'] - original_metrics['expected_return']) 
                                 / abs(original_metrics['expected_return']) * 100)
            # [EMOJI] [EMOJI] [EMOJI] ([EMOJI]: ±1000% [EMOJI])
            return_improvement = max(-1000, min(1000, return_improvement))
        else:
            return_improvement = 0.0
        
        # [EMOJI] [EMOJI] (%)
        if abs(original_metrics['risk']) > EPSILON:
            risk_change = ((optimized_metrics['risk'] - original_metrics['risk']) 
                          / abs(original_metrics['risk']) * 100)
            # [EMOJI] [EMOJI] [EMOJI]
            risk_change = max(-1000, min(1000, risk_change))
        else:
            risk_change = 0.0
        
        # [EMOJI] [EMOJI] [EMOJI] (%)
        if abs(original_metrics['sharpe_ratio']) > EPSILON:
            sharpe_improvement = ((optimized_metrics['sharpe_ratio'] - original_metrics['sharpe_ratio']) 
                                 / abs(original_metrics['sharpe_ratio']) * 100)
            # [EMOJI] [EMOJI] [EMOJI]
            sharpe_improvement = max(-1000, min(1000, sharpe_improvement))
        else:
            sharpe_improvement = 0.0
        
        # [EMOJI] [EMOJI] [EMOJI]
        original_score = original_metrics['expected_return'] / original_metrics['risk'] if original_metrics['risk'] > EPSILON else 0
        optimized_score = optimized_metrics['expected_return'] / optimized_metrics['risk'] if optimized_metrics['risk'] > EPSILON else 0
        
        # [EMOJI] [EMOJI] (%)
        if abs(original_score) > EPSILON:
            score_improvement = ((optimized_score - original_score) / abs(original_score) * 100)
            # [EMOJI] [EMOJI] [EMOJI]
            score_improvement = max(-1000, min(1000, score_improvement))
        else:
            score_improvement = 0.0
        
        result = {
            'original': {
                'tickers': self.tickers,
                'weights': self.initial_weights,
                **original_metrics,
                'optimization_score': float(original_score)
            },
            'optimized': {
                'tickers': self.tickers,
                'weights': optimized_weights,
                **optimized_metrics,
                'optimization_score': float(optimized_score)
            },
            'improvements': {
                'return_improvement': float(return_improvement),
                'risk_change': float(risk_change),
                'sharpe_improvement': float(sharpe_improvement),
                'score_improvement': float(score_improvement)
            },
            'method': method,
            'quantum_verified': method == 'quantum'
        }
        
        # Add quantum-specific metrics if quantum method
        if method == 'quantum' and 'quantum_energy' in optimized_result:
            result['quantum'] = {
                'quantum_energy': optimized_result.get('quantum_energy', 0.0),
                'quantum_probability': optimized_result.get('quantum_probability', 0.0),
                'reps': optimized_result.get('reps', 1)
            }
        
        return result
    
    def optimize(self, method: str = 'classical', **kwargs) -> Dict:
        """
        [EMOJI] [EMOJI] [EMOJI]
        
        Args:
            method: 'classical' [EMOJI] 'quantum'
            **kwargs: [EMOJI] [EMOJI] (quantum[EMOJI] [EMOJI] reps, precision [EMOJI])
        
        Returns:
            [EMOJI] [EMOJI] [EMOJI]
        """
        if method == 'classical':
            return self.optimize_classical()
        elif method == 'quantum':
            reps = kwargs.get('reps', 1)  # [EMOJI]: 1 ([EMOJI]/[EMOJI]), [EMOJI]: 2 [EMOJI]
            precision = kwargs.get('precision', 4)
            return self.optimize_quantum(reps=reps, precision=precision)
        else:
            raise ValueError(f"[EMOJI] [EMOJI] [EMOJI] [EMOJI]: {method}. 'classical' [EMOJI] 'quantum'[EMOJI] [EMOJI].")


def optimize_portfolio(tickers: List[str], risk_factor: float = 0.5, 
                      method: str = 'classical', period: str = "1y", **kwargs) -> Dict:
    """
    [EMOJI] [EMOJI]: [EMOJI] [EMOJI] [EMOJI]
    
    Args:
        tickers: [EMOJI] [EMOJI] [EMOJI]
        risk_factor: [EMOJI] [EMOJI] (0.0 ~ 1.0)
        method: 'classical' [EMOJI] 'quantum'
        period: [EMOJI] [EMOJI] ('1y', '6mo', '3mo' [EMOJI])
        **kwargs: [EMOJI] [EMOJI] (quantum[EMOJI] [EMOJI] reps, precision)
    
    Returns:
        [EMOJI] [EMOJI]
    """
    optimizer = PortfolioOptimizer(tickers, risk_factor)
    optimizer.fetch_data(period=period)
    return optimizer.optimize(method=method, **kwargs)


if __name__ == "__main__":
    # [EMOJI] [EMOJI]
    print("[EMOJI] [EMOJI] [EMOJI] [EMOJI]\n")
    
    # [EMOJI] [EMOJI]
    test_tickers = ['AAPL', 'GOOGL', 'MSFT']
    
    try:
        # [EMOJI] [EMOJI]
        print("=" * 50)
        print("[EMOJI] [EMOJI]")
        print("=" * 50)
        result_classical = optimize_portfolio(
            tickers=test_tickers,
            risk_factor=0.5,
            method='classical',
            period='1y'
        )
        
        print("\n[EMOJI] [EMOJI]:")
        print(f"[EMOJI] [EMOJI]: {result_classical['selected_tickers']}")
        print(f"[EMOJI]: {[f'{w:.2%}' for w in result_classical['weights']]}")
        print(f"[EMOJI] [EMOJI]: {result_classical['expected_return']:.2%}")
        print(f"[EMOJI]: {result_classical['risk']:.2%}")
        print(f"[EMOJI] [EMOJI]: {result_classical['sharpe_ratio']:.2f}")
        
        # [EMOJI] [EMOJI]
        print("\n" + "=" * 50)
        print("[EMOJI] [EMOJI]")
        print("=" * 50)
        result_quantum = optimize_portfolio(
            tickers=test_tickers,
            risk_factor=0.5,
            method='quantum',
            period='1y',
            reps=3,
            precision=4
        )
        
        print("\n[EMOJI] [EMOJI]:")
        print(f"[EMOJI] [EMOJI]: {result_quantum['selected_tickers']}")
        print(f"[EMOJI]: {[f'{w:.2%}' for w in result_quantum['weights']]}")
        print(f"[EMOJI] [EMOJI]: {result_quantum['expected_return']:.2%}")
        print(f"[EMOJI]: {result_quantum['risk']:.2%}")
        print(f"[EMOJI] [EMOJI]: {result_quantum['sharpe_ratio']:.2f}")
        if 'quantum_energy' in result_quantum:
            print(f"[EMOJI] [EMOJI]: {result_quantum['quantum_energy']:.6f}")
            print(f"[EMOJI] [EMOJI]: {result_quantum['quantum_probability']:.4f}")
        
        # [EMOJI]
        print("\n" + "=" * 50)
        print("[EMOJI] [EMOJI]")
        print("=" * 50)
        
        # Weight comparison
        classical_weights_dict = dict(zip(result_classical['selected_tickers'], result_classical['weights']))
        quantum_weights_dict = dict(zip(result_quantum['selected_tickers'], result_quantum['weights']))
        
        all_tickers = set(result_classical['selected_tickers'] + result_quantum['selected_tickers'])
        weight_diffs = []
        for ticker in all_tickers:
            classical_w = classical_weights_dict.get(ticker, 0.0)
            quantum_w = quantum_weights_dict.get(ticker, 0.0)
            diff = abs(classical_w - quantum_w)
            weight_diffs.append(diff)
            print(f"  {ticker}: Classical={classical_w:.2%}, Quantum={quantum_w:.2%}, Diff={diff:.2%}")
        
        avg_weight_diff = np.mean(weight_diffs) if weight_diffs else 0.0
        print(f"\n[EMOJI] [EMOJI] [EMOJI]: {avg_weight_diff:.2%}")
        print(f"[EMOJI] [EMOJI]: {(result_quantum['expected_return'] - result_classical['expected_return']):.4%}")
        print(f"[EMOJI] [EMOJI]: {(result_quantum['risk'] - result_classical['risk']):.4%}")
        print(f"[EMOJI] [EMOJI] [EMOJI]: {(result_quantum['sharpe_ratio'] - result_classical['sharpe_ratio']):.4f}")
        
        if avg_weight_diff < 0.05:
            print("\n[WARNING] [EMOJI] [EMOJI] [EMOJI] [EMOJI]. [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI].")
        else:
            print("\n[SUCCESS] [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]!")
        
    except Exception as e:
        print(f"[ERROR] [EMOJI] [EMOJI]: {str(e)}")
        import traceback
        traceback.print_exc()

